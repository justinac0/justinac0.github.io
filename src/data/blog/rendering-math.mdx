---
title: 'Rendering Math Fundamentals'
author: 'Justin Chappell'
description: 'In this article I go through the fundamentals of the mathematics required for rendering 3D rasterized graphics.'
date: 2024-12-30
slug: 'rendering-math'
tags: ['math', 'graphics']
published: true
---

import Latex from '../../components/Latex.astro';
import MDImage from '../../components/MDImage.astro';

# Rendering Math Fundamentals

## Introduction
Have you ever wondered how computers display 3D graphics?
How can we depict 3D environment on a '2D' screen?
In this blog I will attempt to demistify this process.

<MDImage src="/blog/rendering-math/cryengine.jpg" alt="screenshot from cryengine" ref="https://store.steampowered.com/app/220980/CRYENGINE/" />

What 3D graphics renderes rasterizers do is relativly simple,
they project geometry defined in 3D space onto a 2D rectangle (your screen).

<MDImage src="/blog/rendering-math/view.png" alt="" customStyle="background-color: #fff; padding: 2rem;" ref="https://www.baeldung.com/wp-content/uploads/sites/4/2023/05/perspective-projection-1.png"/>

Here is the equation that computes the projection of 3D geometry onto
the view plane.

<Latex formula='\vec{v_p}\prime=PVM\vec{v_p}'/>

On the *LHS* we have our final vertex position (projected to our view rectangle), and on the *RHS* we
see the perspective, view and model matricies multiplied against our
vertex position in 3D space.

{/* ![](/blog/rendering-math/3D-chunk.png "rendering some voxels") */}

1. **Perspective (<Latex formula='P' />)**: As the name suggest this matrix defines the
what objects look like at different distances from our view.
Effectively defining what is called the view frustrum. Objects closer
to the origin of our view will appear bigger or smaller depending
on the type of frustrum created. This gives us the ability to percieve
depth.

<MDImage src="/blog/rendering-math/perspective.jpg" alt="" customStyle="background-color: #fff; padding: 2rem;" ref="https://i.sstatic.net/Eh4rc.jpg"/>

There are plenty of [different](https://en.wikipedia.org/wiki/3D_projection) perspective matricies at our dispense,
but by far the most common one used in 3D games/graphics is the
perspective projection matrix.

2. **View (<Latex formula='V' />)**: We can think of the view matrix as a sort of camera. Different
from cameras in real life however this camera has less to do with light sensors
and more to do with where we are and what are we looking. There are many
different ways to form this matrix, but we will be looking specifically at
a special matrix called the lookat matrix.

3. **Model (<Latex formula='M' />)**: If we wish to either scale, rotate or translate and object in a 3D scene
we can do that through the model matrix. This matrix defines the scale rotation and location of an object in
our 3D scene.

Now with that brief overview of what we are aiming towards, I will now spend
the rest of this blog going through the mathematics required to implement
such a renderer.

## Vectors

Vectors describe different things depending on their context. They are useful
in grouping similar information into a neat package. In graphics vectors
can be used to describe positions of vertices (xyz), colors (rgb), quaternions (wxyz).
For most cases the values are float/reals, but sometimes it may come in handy
to have interger based components or other types.
### Operations 

**ADDITION:** <Latex formula='\vec{a}+\vec{b}=\begin{bmatrix}x\\y\\z\end{bmatrix}+\begin{bmatrix}x\\y\\z\end{bmatrix}=\begin{bmatrix}2x\\2y\\2z\end{bmatrix}\\' />
Add two vectors component-wise.

**SUBTRACT:** <Latex formula='\vec{a}-\vec{b}=\begin{bmatrix}x\\y\\z\end{bmatrix}-\begin{bmatrix}x\\y\\z\end{bmatrix}=\begin{bmatrix}0\\0\\0\end{bmatrix}\\' />
Subtract two vectors component-wise.


**MULTIPLY:** <Latex formula='\vec{a}\vec{b}=\begin{bmatrix}x\\y\\z\end{bmatrix}\begin{bmatrix}x\\y\\z\end{bmatrix}=\begin{bmatrix}x^2\\y^2\\z^2\end{bmatrix}\\' />
Multiply two vectors component-wise.


**DOT:** <Latex formula='\vec{a}\cdot\vec{b}=\vec{a}\cdot\vec{b}=\begin{bmatrix}x\\y\\z\end{bmatrix}\cdot\begin{bmatrix}x\\y\\z\end{bmatrix}=a_0b_0+a_0b_0+a_1b_1\\' />
The inner product of two same length vectors results in a scalar value showing the similarity in pointing direction of the to vectors.

**CROSS:** <Latex formula='\vec{a}\times\vec{b}=
\begin{bmatrix}
 a_1b_2 - a_2b_1\\
-a_0b_2 - a_2b_0\\
 a_0b_1 - a_1b_0
\end{bmatrix}\\' />
Produces an orthogonal vector to both vectors.

**MAGNITUDE:** <Latex formula='|\vec{a}|=\sqrt{a_x^2+a_y^2+a_z^2}\\' />
Vector length.

**UNIT:** <Latex formula='\hat{a}=\frac{\vec{a}}{|\vec{a}|}\\' />
Unit length vector (length of 1).

## Matrices

Similarly to vectors, the contents of a matrix depend on the context that
you use them. In most of 3D graphics we will be dealing with 4x4 (float/real values) matrices.
Graphics APIs like OpenGL don't care if your matricies are row or column
major; however, whatever major you major in :) keep it consistent. Furthermore,
if you are in the wrong major just transpose the matrix in question.

### Operations

*IDENTITY*: <Latex formula='I=
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}\\' />


*ADDITION:* <Latex formula='A+B=\\' />


*SUBTRACT:* <Latex formula='A-B=\\' />


*MULTIPLY:* <Latex formula='AB=\\' />


*TRANSPOSE:* <Latex formula='A^T=\\' />

{/* *INVERSE:* <Latex formula='A^{-1}=\\' /> */}


## Matrix Transformations

In this section I will cover the basic transformation matrices required to
scale, rotate and translate geometry. These matricies are fundamental
for creating a model matrix as well as manipulating the view (camera)
matrix.

### Scale

<Latex formula='\begin{bmatrix}
S_x & 0 & 0 & 0\\
0 & S_y & 0 & 0\\
0 & 0 & S_z & 0\\
0 & 0 & 0 & 0\\
\end{bmatrix}'/>

### Translation

<Latex formula='\begin{bmatrix}
0 & 0 & 0 & T_x\\
0 & 0 & 0 & T_y\\
0 & 0 & 0 & T_z\\
0 & 0 & 0 & 0\\
\end{bmatrix}'/>

### Rotation

I will only cover euler rotations here; however, there
are more efficient ways to calculate the rotation matrix.
Namely through the use of quaternions. I will cover
quaternions in a seperate blog eventually.

For each axis we need to define a 3x3 rotation matrix.

The final rotation matrix is formed by multiplying in order 
of yaw pitch and roll <Latex formula='R=R_z(\theta_z)R_y(\theta_y)R_x(\theta_x)' />.

*<Latex formula='R_x(\theta)=' />*<Latex formula='\begin{bmatrix}
1 & 0 & 0\\
0 & cos{\theta} & -sin{\theta}\\
0 & sin{\theta} & cos{\theta}\\
\end{bmatrix}\\'/>

*<Latex formula='R_y(\theta)=' />*<Latex formula='\begin{bmatrix}
cos{\theta} & 0 & sin{\theta}\\
0 & 1 & 0\\
-sin{\theta} & 0 & cos{\theta}\\
\end{bmatrix}\\'/>

*<Latex formula='R_z(\theta)=' />*<Latex formula='\begin{bmatrix}
cos{\theta} & -sin{\theta} & 0\\
sin{\theta} & cos{\theta} & 0\\
0 & 0 & 1\\
\end{bmatrix}'/>

In practice the rotation matrix is actually a 4x4 matrix (just zero out the new row and column). This
enables the multiplcation of this matrix against the scale and
translation matrix to form the model matrix <Latex formula='M' />.

## Special Matricies

### Perspective

{/* ### Orthographic */}

### View

### Lookat

## Putting it all together

## Conclusion

## Helpful Resources
- [Linear Algebra Done Right (Text Book)](https://linear.axler.net/)
- [MIT Linear Algebra Course (Course)](https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/)
- [Model View Projection (ARTICLE)](https://jsantell.com/model-view-projection/)
- [Essence of linear algebra (Video Playlist)](https://www.youtube.com/watch?v=fNk_zzaMoSs&list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab)